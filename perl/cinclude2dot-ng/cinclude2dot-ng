#!/usr/bin/env perl

# This is a tool inspired by cinclude2dot
# The original can be found here: http://www.chaosreigns.com/code/cinclude2dot/
# An improved version is to be found here: http://www.flourish.org/cinclude2dot/
#
# I wanted a tool that could perform the same tasks, but I would like to be able
# to specify the point where it should stop searching. I have rewritten cincludedot
# so that it uses breadth first search (shove as much files on a queue as you can,
# then pop the first item and push all its nodes a the front of the queue. Rinse and
# repeat). Inserting level markers gave me an easy way to keep track of the depth.
#
# Tasks left to implement:
#  - the --merge and --groups parameters
#  - the -- quotetypes parameter
#  - using gcc to check the header files (compile header file standalone)
#  - using gcc to check the unnecessary header files (comment out a single file and try to compile)

use strict;
use warnings;
use Getopt::Long;
use File::Find;
use File::Basename;
use Cwd;

my $file="";
my $level=0;
my @file_queue;

# options
my $debug = '';
my $help = '';
my @includepaths;
my $maxlevel = 0;
my $outputfile="./out.dot";
my $exclude="/^\$/";

sub usage()
{
	print "$0 [file] [directory]\n";
	print "Supply one or more files / directories to search for source files\n";
	print "If no files are supplied, the current directory is used\n";
	print "Please define the following options:\n";
	print "\t--debug        = be verbose\n";
	print "\t--includepaths = a comma separated list of include paths to search\n";
	print "\t--maxlevel     = fill the include 'tree' up to maxlevel levels deep (default = 1)\n";
	print "\t--outputfile   = fill the include 'tree' up to maxlevel levels deep (default = ./out.dot)\n";
	print "\t--exclude      = a perl regex of files to exclude\n";

	exit(1);
}

sub wanted()
{
	my $pwd = cwd();
	$debug and print "parsing subdirs: $pwd/$_\n";
	matchfile($pwd."/".$_);

}

sub matchfile($)
{
	$_[0] =~ $exclude and return;

	# match any file ending in .c .C .cc .CC .cxx .cpp .h .hpp .hxx
	$_[0] =~ /.*\.[cC]{1,2}$/ and push(@file_queue, $_[0]);
	$_[0] =~ /.*\.cpp$/ and push(@file_queue, $_[0]);
	$_[0] =~ /.*\.cxx$/ and push(@file_queue, $_[0]);
	$_[0] =~ /.*\.h$/ and push(@file_queue, $_[0]);
	$_[0] =~ /.*\.hpp$/ and push(@file_queue, $_[0]);
	$_[0] =~ /.*\.hxx$/ and push(@file_queue, $_[0]);
}

sub printqueue()
{
	print "The queue\n";
	foreach $file (@file_queue){
		print "$file\n";
	}
}

sub findinclude($$$)
{
	my $include          = $_[0];
	my $localinclude     = $_[1];
	my $localincludepath = $_[2];

	if ($localinclude) {
		if(-e $localincludepath."/".$include){
			$debug and print "Found include $include in $localincludepath\n";
			return $localincludepath."/".$include;
		}
	}

	foreach my $includepath (@includepaths){
		if(-e $includepath."/".$include){
			$debug and print "Found include $include in $includepath\n";
			return $includepath."/".$include;
		}
	}

	print "Could not find $include\n";
	return "";
}

# forward declaration of recursive function to avoid the 'called too early to check 
# prototype' warning
sub parsefileforheaders;

sub parsefileforheaders($)
{
	$level >= $maxlevel and return;

	if ($_[0] eq "levelmarker") {
		$level++;
		unshift(@file_queue, "levelmarker");
		$debug and printqueue();

	} else {
		$debug and print "parsing file $_[0] for headers\n";

		my $outputfilestring = "    \"$_[0]\" -> {";
		#   "putmpg.c" -> { "config.h" "global.h" "stdio.h" "stdio.h" }

		if( -e $_[0]){
			open(INPUT, "<$_[0]");
			my @lines = <INPUT>;
			my @includes = grep{/^\#\s*include\s+<(\S+)>$/; defined $1 and $_=$1;} @lines;
			my @localincludes = grep{/^\#\s*include\s+"(\S+)"$/; defined $1 and $_=$1;} @lines;
			close(INPUT);
			
			$debug and print "$_[0] contains @localincludes @includes\n";

			# add includes with full path to queue
			if(@includes > 0){
				foreach my $include (@includes){
					my $includefull = findinclude($include, 0, "");
					if($includefull ne ""){
						unshift(@file_queue, $includefull);
						$outputfilestring = $outputfilestring . " \"" . $includefull . "\"";
					}
				}
			}

			# add local includes with full path to queue
			if(@localincludes > 0){
				foreach my $include (@localincludes){
					my $includefull = findinclude($include, 1, dirname($_[0]));
					if($includefull ne ""){
						unshift(@file_queue, $includefull);
						$outputfilestring = $outputfilestring . " \"" . $includefull . "\"";
					}
				}
			}
		}
		$outputfilestring = $outputfilestring . " }\n";
		print OUTPUT $outputfilestring;
	}

	if (@file_queue > 0) {
		parsefileforheaders(pop(@file_queue));
	}
}

################################################################################
# main
GetOptions('debug' => \$debug, 'help' => \$help, 'includepaths=s' => \@includepaths, 'maxlevel=i' => \$maxlevel, 'outputfile=s' => \$outputfile, 'exclude=s' => \$exclude);
@includepaths = split(/,/,join(',',@includepaths)); # allow multiple --includepaths directives
$debug and print "@includepaths\n";

if ($help) {
	usage();
}

# Use default of ./ if no argument is supplied
if (!defined $ARGV[0]) {
	push(@ARGV, "./");
}

# Detect if arguments are directories or files.
foreach $file (@ARGV){
	# add supplied source files to the queue
	matchfile($file);

	# argument starts with / or ./, must be directory: search for source files
	if (($file =~ /^\//) || ($file =~ /\.\//)) {
		find (\&wanted, $file);
	}

	#print "$file\n";
}

# Queue now filled with 0th level files, insert sentinel
unshift(@file_queue, "levelmarker");

$debug and printqueue();
open(OUTPUT,">$outputfile");

my $header=<<END;
digraph "source tree" {
    overlap=scale;
    size="8,10";
    ratio="fill";
    fontsize="16";
    fontname="Helvetica";
    clusterrank="local";
END

print OUTPUT $header;

parsefileforheaders(pop(@file_queue)); # start at back of queue

print OUTPUT "}\n";
close(OUTPUT);
